#!/usr/bin/env python
# coding: utf-8

import os
import logging

import healpy as hp
import numpy as np
import fitsio

from . import utils


logger = logging.getLogger('Footprint')


class Footprint(object):
    """
    Base class for footprint given as argument in PhotometricDataFrame.
    New footprint need to contain at least the following attributes and methods.
    """
    def __init__(self, nside=256):
        """
        Initialize :class:`Footprint` .

        Parameters
        ----------
        nside: int, default=256
            The resolution of the Healpix masks.
        """
        self.nside = 256
        self.verbose = True
        self.default_regions = ['Footprint']

    def __call__(self, region):
        """
        Method that returns mask for the a specific region.
        Must be implemented in your new footprint.
        """
        raise NotImplementedError('Implement method "__call__" in your {}'.format(self.__class__.__name__))

    def get_normalization_zone(self, region):
        """
        Return mask to extract the zone used to evaluate the mean density in input region.
        Use only if PhotometricDataFrame.use_new_norm == True.
        """
        return self(region)


class DR9Footprint(Footprint):
    """
    Specific class for the photometric footprint DR9 of the Legacy Imaging Surveys.
    It loads information about DESI / DR9 footprint and the different photometric footprints or regions of interest.
    It is based on `Data/Legacy_Imaging_DR9_footprint_256.fits` which is built from the fracarea_12290 given by the pixweight
    generated by desitarget. DES imprint is extracted from an old file given by Anand (at DR8 release).

    The file is generated here at NERSC in: `/global/homes/e/edmondc/Target_Selection/Build_footprint_file/`.

    Reference: https://www.legacysurvey.org/

    Name: North = MzLS, South = DECaLS (without DES), Des = DES
    WARNING: ISSOUTH is everything with Dec. < 32.275
    """

    def __init__(self, nside=256, mask_lmc=False, clear_south=False, mask_around_des=False, cut_desi=False, pixmap=None, verbose=True):
        """
        Initialize :class:`DR9Footprint` .

        Parameters
        ----------
        nside : int, default=256
            Give the resolution of the output masks.
        mask_lmc : bool, default=False
            Mask out the Large Magellanic Cloud, useful for QSO target selection.
        clear_south : bool, default=False
            Mask out disconnected area in the NGC South. This region will be not used in DESI and have small fraction of area covered and bad observational conditions.
        mask_around_des : bool, default=False
            Mask the border of the footprint around DES which is contained in South; useful for systematic weights and avoid strange area in the K-fold training. This zone will not be observed by DESI.
        cut_desi : bool, default=False
            Mask out the south part of the NGC with Dec. < -30. It is expected to be not observed with the nominal DESI Y5.
        pixmap : bool array or str, default=None
            Footprint map array, or path to the .fits file containg this array. Defaults to footprint in ./data/.
        verbose : bool, default=True
            Enable or not to display info with logger. Usefull if DR9Footprint is used with MPI.
        """
        self.nside = nside
        self.mask_lmc = mask_lmc
        self.clear_south = clear_south
        self.mask_around_des = mask_around_des
        self.cut_desi = cut_desi
        self.verbose = verbose
        if self.verbose:
            logger.info(f'Load DR9 footprint with nside={nside}, mask_lmc={self.mask_lmc}, clear_south={self.clear_south}, mask_around_des={self.mask_around_des} and cut_desi={self.cut_desi}')

        path_pixmap = None
        if isinstance(pixmap, str):
            path_pixmap = pixmap
        elif pixmap is None:
            path_pixmap = os.path.join(os.path.dirname(__file__), 'data', 'Legacy_Imaging_DR9_footprint_256.fits')

        if path_pixmap is not None:
            self.data = fitsio.read(path_pixmap)
        else:
            self.data = pixmap

        self.default_regions = ['North', 'South', 'Des']
        # remark: Global = Footprint, South_ngc = South_all_ngc = South_mid_ngc
        self.available_regions = ['North', 'South', 'South_ngc', 'South_sgc', 'Des', 'South_all', 'South_all_ngc', 'South_all_sgc',
                                  'South_mid', 'South_mid_ngc', 'South_mid_sgc', 'South_pole', 'Des_mid', 'Global', 'Footprint']

    def update_map(self, pixmap, copy=True):
        """
        Apply mask and ud_grade input pixmap.

        Parameters
        ----------
        pixmap : bool array
            pixmap to return with mask at the correct nside.

        copy : bool, default=True
            Whether to copy input pixmap.

        Returns
        -------
        pixmap : bool array
            pixmap with mask at the correct nside.
        """
        if copy:
            pixmap = pixmap.copy()

        if self.mask_lmc:
            pixmap[utils.hp_in_box(256, [52, 120, -90, -50], inclusive=True)] = False

        if self.clear_south:
            pixmap[utils.hp_in_box(256, [120, 150, -45, -10], inclusive=True) + utils.hp_in_box(256, [150, 180, -45, -15], inclusive=True) + utils.hp_in_box(256, [210, 240, -20, -12], inclusive=True)] = False

        if self.mask_around_des:
            mask_around_des = np.zeros(hp.nside2npix(256), dtype=bool)
            mask_around_des[utils.hp_in_box(256, [-120, 0, -90, -18.5], inclusive=True) + utils.hp_in_box(256, [0, 120, -90, -17.4], inclusive=True)] = True
            mask_around_des[self.data['ISDES']] = False
            pixmap[mask_around_des] = False

        if self.cut_desi:  # restricted to DESI footprint
            pixmap[utils.hp_in_box(self.nside, [0, 360, -90, -30])] = False

        if self.nside != 256:
            pixmap = hp.ud_grade(pixmap, self.nside, order_in='NESTED')

        return pixmap

    def get_full(self):
        """Return full DR9 footprint -> healpix map with :attr:`nside` in nested ordering."""
        return self.update_map(self.data['ISDR9'])

    def get_ngc_sgc(self):
        """Return NGC and SGC masks -> healpix map with :attr:`nside` in nested ordering."""
        return self.update_map(self.data['ISNGC']), self.update_map(self.data['ISSGC'])

    def get_imaging_surveys(self, ngc_sgc_split=False):
        """
        Return North, South, Des.

        Parameters
        ----------
        ngc_sgc_split : bool
            Split into NGC / SGC region.

        Returns
        -------
        (North, South, Des) or (North, South_ngc, South_sgc, Des) if ngc_sgc_split=True -> healpix map with :attr:`nside` in nested ordering.
        """
        if ngc_sgc_split:
            return self.update_map(self.data['ISNORTH']), self.update_map(self.data['ISSOUTH'] & ~self.data['ISDES'] & self.data['ISNGC']), self.update_map(self.data['ISSOUTH'] & ~self.data['ISDES'] & self.data['ISSGC']), self.update_map(self.data['ISDES'])

        return self.update_map(self.data['ISNORTH']), self.update_map(self.data['ISSOUTH'] & ~self.data['ISDES']), self.update_map(self.data['ISDES'])

    def get_elg_region(self, ngc_sgc_split=False):
        """
        Return North / South & DES (-30 < Dec. < 32.275) / DES (Dec. < -30) and split the South part in NGC / SGC part if required.

        Parameters
        ----------
        ngc_sgc_split : bool
            Split into NGC / SGC region.

        Returns
        -------
        (North, South_mid, South_pole) or (North, South_mid_ngc, South_mid_sgc, South_pole) if ngc_sgc_split=True -> healpix map with :attr:`nside` in nested ordering.
        """
        dec, all_south = self.data['DEC'], self.data['ISSOUTH']

        south_mid = all_south.copy()
        south_mid[dec <= -30] = False

        south_pole = all_south.copy()
        south_pole[dec > -30] = False

        if ngc_sgc_split:
            return self.update_map(self.data['ISNORTH']), self.update_map(south_mid & self.data['ISNGC']), self.update_map(south_mid & self.data['ISSGC']), self.update_map(south_pole)

        return self.update_map(self.data['ISNORTH']), self.update_map(south_mid), self.update_map(south_pole)

    def __call__(self, region):
        """
        Healpix mask with :attr:`nside` in nested ordering to select the input region.

        Parameters
        ----------
        region : str
            Region to select.
        """
        region = region.lower()
        if region in ['global', 'footprint']:
            return self.get_full()
        elif region == 'north':
            return self.get_imaging_surveys()[0]
        elif region == 'south':
            return self.get_imaging_surveys()[1]
        elif region == 'south_ngc':
            return self.get_imaging_surveys(ngc_sgc_split=True)[1]
        elif region == 'south_sgc':
            return self.get_imaging_surveys(ngc_sgc_split=True)[2]
        elif region == 'des':
            return self.get_imaging_surveys()[2]
        elif region == 'des_mid':
            return self.get_imaging_surveys()[2] & ~self.get_elg_region()[2]
        elif region == 'south_mid':
            return self.get_elg_region()[1]
        elif region == 'south_mid_ngc':
            return self.get_elg_region(ngc_sgc_split=True)[1]
        elif region == 'south_mid_sgc':
            return self.get_elg_region(ngc_sgc_split=True)[2]
        elif region == 'south_pole':
            return self.get_elg_region()[2]
        elif region == 'south_all':
            return self.get_imaging_surveys()[1] | self.get_imaging_surveys()[2]
        elif region == 'south_all_ngc':
            return (self.get_imaging_surveys()[1] | self.get_imaging_surveys()[2]) & self.get_ngc_sgc()[0]
        elif region == 'south_all_sgc':
            return (self.get_imaging_surveys()[1] | self.get_imaging_surveys()[2]) & self.get_ngc_sgc()[1]
        raise ValueError(f"Call of {self.__class__.__name__} is not implemented for region: {region}")

    def get_normalization_zone(self, region):
        """
        Return mask with :attr:`nside` in nested ordering used to extract the zone used to evaluate the mean density in input region.
        Such zone choosen in the middle of the NGC. Far from the galactic plane, eclipic pole and Sgr. Stream to avoid stellar contamination.

        Parameters
        ----------
        region : str
            Region to get normalization zone for.
        """
        region = region.lower()
        keep_to_norm = np.zeros(hp.nside2npix(self.nside), dtype='?')
        if region == 'north':
            if self.verbose:
                logger.info("Use (R.A., Dec.) box: [120, 240, 32.2, 40] to compute mean density")
            keep_to_norm[utils.hp_in_box(self.nside, [120, 240, 32.2, 40], inclusive=True)] = True
        elif region in ['south', 'south_ngc', 'south_mid', 'south_mid_ngc', 'south_all', 'south_all_ngc']:
            if self.verbose:
                logger.info("Use (R.A., Dec.) box: [120, 240, 24, 32.2] to compute mean density")
            keep_to_norm[utils.hp_in_box(self.nside, [120, 240, 24, 32.2], inclusive=True)] = True
        else:
            keep_to_norm[:] = True
            if self.verbose:
                logger.info("No restriction to compute mean density")
        return keep_to_norm


class DESIFootprint(Footprint):
    """
    Specific class for the DESI footprint.
    It loads information about DESI / DR9 footprint and the different photometric footprints or regions of interest.
    It is based on `Data/DESI_footprint_512.fits` which is built from  `desimodel.footprint` and from tiles collected with
    `desimodel.io.load_tiles()` and extracted from tiles-fuji.csv / tiles-guadalupe.csv

    The file is generated here at NERSC in `/global/homes/e/edmondc/Target_Selection/Build_footprint_file/`.

    Name: Y5 = nominal desi footprint, Y1 = footprint for DR1, DA02 = first two months of observation
    """

    def __init__(self, nside=256, pixmap=None, default_region='y5', default_program='dark', verbose=True):
        """
        Initialize :class:`DR9Footprint` .

        Parameters
        ----------
        nside : int, default=256
            Give the resolution of the output masks.
        pixmap : bool array or str, default=None
            Footprint map array, or path to the .fits file containg this array. Defaults to footprint in ./data/.
        default_region : str, default='y5'
            default region to call DESIFootprint()() without arguments.
        default_program : str, default='dark'
            default program to call DESIFootprint()() without arguments.
        verbose : bool, default=True
            Enable or not to display info with logger. Usefull if DR9Footprint is used with MPI.
        """
        self.nside = nside
        self.verbose = verbose
        if self.verbose:
            logger.info(f'Load DESI footprint with nside={self.nside}')

        path_pixmap = None
        if isinstance(pixmap, str):
            path_pixmap = pixmap
        elif pixmap is None:
            path_pixmap = os.path.join(os.path.dirname(__file__), 'data', 'DESI_footprint_256.fits')

        if path_pixmap is not None:
            self.data = fitsio.read(path_pixmap)
        else:
            self.data = pixmap

        self.default_regions = [default_region]
        self.default_program = 'dark'
        # remark: Global = Footprint = Y5
        self.available_regions = ['sv1', 'sv2', 'sv3', 'da02', 'y1', 'y1-3pass', 'y5', 'global', 'footprint']
        self.available_programs = ['dark', 'bright']

    def update_map(self, pixmap, copy=True):
        """
        Apply mask and ud_grade input pixmap.

        Parameters
        ----------
        pixmap : bool array
            pixmap to return with mask at the correct nside.

        copy : bool, default=True
            Whether to copy input pixmap.

        Returns
        -------
        pixmap : bool array
            pixmap with mask at the correct nside.
        """
        if copy:
            pixmap = pixmap.copy()

        if self.nside != hp.npix2nside(pixmap.size):
            pixmap = hp.ud_grade(pixmap, self.nside, order_in='NESTED')

        return pixmap

    def __call__(self, region=None, program=None):
        """
        Healpix mask with :attr:`nside` in nested ordering to select the input region.

        Parameters
        ----------
        region : str
            Region to select.
        """
        if region is None:
            region = self.default_regions[0]
        if program is None:
            program = self.default_program

        region, program = region.lower(), program.lower()
        if region in ['y5', 'global', 'footprint']:
            region = 'y5'

        if (region in self.available_regions) and (program in self.available_programs):
            return self.update_map(self.data[region + '-' + program])

        raise ValueError(f"Call of {self.__class__.__name__} is not implemented for region: {region} or {program}")
